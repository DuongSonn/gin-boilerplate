// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"oauth-server/graphql/model"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/google/uuid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	OAuth() OAuthResolver
	Query() QueryResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Mutation struct {
		OAuth func(childComplexity int) int
		User  func(childComplexity int) int
	}

	OAuth struct {
		CreatedAt func(childComplexity int) int
		ExpireAt  func(childComplexity int) int
		ID        func(childComplexity int) int
		IP        func(childComplexity int) int
		LoginAt   func(childComplexity int) int
		Platform  func(childComplexity int) int
		Status    func(childComplexity int) int
		Token     func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		User      func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	OAuthMutation struct {
		Create       func(childComplexity int, input model.CreateOAuthInput) int
		Revoke       func(childComplexity int, id uuid.UUID) int
		RevokeAll    func(childComplexity int, userID uuid.UUID) int
		UpdateStatus func(childComplexity int, id uuid.UUID, status model.OAuthStatus) int
	}

	OAuthQuery struct {
		ActiveList func(childComplexity int, userID uuid.UUID) int
		Get        func(childComplexity int, id uuid.UUID) int
		List       func(childComplexity int, limit *int32, offset *int32, userID *uuid.UUID, platform *model.OAuthPlatform, status *model.OAuthStatus) int
	}

	Query struct {
		OAuth func(childComplexity int) int
		User  func(childComplexity int) int
	}

	User struct {
		CreatedAt   func(childComplexity int) int
		Email       func(childComplexity int) int
		ID          func(childComplexity int) int
		IsActive    func(childComplexity int) int
		OAuths      func(childComplexity int) int
		Password    func(childComplexity int) int
		PhoneNumber func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	UserMutation struct {
		Create         func(childComplexity int, input model.CreateUserInput) int
		Delete         func(childComplexity int, id uuid.UUID) int
		ToggleActive   func(childComplexity int, id uuid.UUID) int
		Update         func(childComplexity int, id uuid.UUID, input model.UpdateUserInput) int
		UpdatePassword func(childComplexity int, id uuid.UUID, input model.UpdatePasswordInput) int
	}

	UserQuery struct {
		Get  func(childComplexity int, id uuid.UUID) int
		List func(childComplexity int, limit *int32, offset *int32, isActive *bool) int
		Me   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Mutation.o_auth":
		if e.complexity.Mutation.OAuth == nil {
			break
		}

		return e.complexity.Mutation.OAuth(childComplexity), true

	case "Mutation.user":
		if e.complexity.Mutation.User == nil {
			break
		}

		return e.complexity.Mutation.User(childComplexity), true

	case "OAuth.created_at":
		if e.complexity.OAuth.CreatedAt == nil {
			break
		}

		return e.complexity.OAuth.CreatedAt(childComplexity), true

	case "OAuth.expire_at":
		if e.complexity.OAuth.ExpireAt == nil {
			break
		}

		return e.complexity.OAuth.ExpireAt(childComplexity), true

	case "OAuth.id":
		if e.complexity.OAuth.ID == nil {
			break
		}

		return e.complexity.OAuth.ID(childComplexity), true

	case "OAuth.ip":
		if e.complexity.OAuth.IP == nil {
			break
		}

		return e.complexity.OAuth.IP(childComplexity), true

	case "OAuth.login_at":
		if e.complexity.OAuth.LoginAt == nil {
			break
		}

		return e.complexity.OAuth.LoginAt(childComplexity), true

	case "OAuth.platform":
		if e.complexity.OAuth.Platform == nil {
			break
		}

		return e.complexity.OAuth.Platform(childComplexity), true

	case "OAuth.status":
		if e.complexity.OAuth.Status == nil {
			break
		}

		return e.complexity.OAuth.Status(childComplexity), true

	case "OAuth.token":
		if e.complexity.OAuth.Token == nil {
			break
		}

		return e.complexity.OAuth.Token(childComplexity), true

	case "OAuth.updated_at":
		if e.complexity.OAuth.UpdatedAt == nil {
			break
		}

		return e.complexity.OAuth.UpdatedAt(childComplexity), true

	case "OAuth.user":
		if e.complexity.OAuth.User == nil {
			break
		}

		return e.complexity.OAuth.User(childComplexity), true

	case "OAuth.user_id":
		if e.complexity.OAuth.UserID == nil {
			break
		}

		return e.complexity.OAuth.UserID(childComplexity), true

	case "OAuthMutation.create":
		if e.complexity.OAuthMutation.Create == nil {
			break
		}

		args, err := ec.field_OAuthMutation_create_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.OAuthMutation.Create(childComplexity, args["input"].(model.CreateOAuthInput)), true

	case "OAuthMutation.revoke":
		if e.complexity.OAuthMutation.Revoke == nil {
			break
		}

		args, err := ec.field_OAuthMutation_revoke_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.OAuthMutation.Revoke(childComplexity, args["id"].(uuid.UUID)), true

	case "OAuthMutation.revoke_all":
		if e.complexity.OAuthMutation.RevokeAll == nil {
			break
		}

		args, err := ec.field_OAuthMutation_revoke_all_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.OAuthMutation.RevokeAll(childComplexity, args["user_id"].(uuid.UUID)), true

	case "OAuthMutation.update_status":
		if e.complexity.OAuthMutation.UpdateStatus == nil {
			break
		}

		args, err := ec.field_OAuthMutation_update_status_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.OAuthMutation.UpdateStatus(childComplexity, args["id"].(uuid.UUID), args["status"].(model.OAuthStatus)), true

	case "OAuthQuery.active_list":
		if e.complexity.OAuthQuery.ActiveList == nil {
			break
		}

		args, err := ec.field_OAuthQuery_active_list_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.OAuthQuery.ActiveList(childComplexity, args["user_id"].(uuid.UUID)), true

	case "OAuthQuery.get":
		if e.complexity.OAuthQuery.Get == nil {
			break
		}

		args, err := ec.field_OAuthQuery_get_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.OAuthQuery.Get(childComplexity, args["id"].(uuid.UUID)), true

	case "OAuthQuery.list":
		if e.complexity.OAuthQuery.List == nil {
			break
		}

		args, err := ec.field_OAuthQuery_list_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.OAuthQuery.List(childComplexity, args["limit"].(*int32), args["offset"].(*int32), args["user_id"].(*uuid.UUID), args["platform"].(*model.OAuthPlatform), args["status"].(*model.OAuthStatus)), true

	case "Query.o_auth":
		if e.complexity.Query.OAuth == nil {
			break
		}

		return e.complexity.Query.OAuth(childComplexity), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		return e.complexity.Query.User(childComplexity), true

	case "User.created_at":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.is_active":
		if e.complexity.User.IsActive == nil {
			break
		}

		return e.complexity.User.IsActive(childComplexity), true

	case "User.o_auths":
		if e.complexity.User.OAuths == nil {
			break
		}

		return e.complexity.User.OAuths(childComplexity), true

	case "User.password":
		if e.complexity.User.Password == nil {
			break
		}

		return e.complexity.User.Password(childComplexity), true

	case "User.phone_number":
		if e.complexity.User.PhoneNumber == nil {
			break
		}

		return e.complexity.User.PhoneNumber(childComplexity), true

	case "User.updated_at":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "UserMutation.create":
		if e.complexity.UserMutation.Create == nil {
			break
		}

		args, err := ec.field_UserMutation_create_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UserMutation.Create(childComplexity, args["input"].(model.CreateUserInput)), true

	case "UserMutation.delete":
		if e.complexity.UserMutation.Delete == nil {
			break
		}

		args, err := ec.field_UserMutation_delete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UserMutation.Delete(childComplexity, args["id"].(uuid.UUID)), true

	case "UserMutation.toggle_active":
		if e.complexity.UserMutation.ToggleActive == nil {
			break
		}

		args, err := ec.field_UserMutation_toggle_active_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UserMutation.ToggleActive(childComplexity, args["id"].(uuid.UUID)), true

	case "UserMutation.update":
		if e.complexity.UserMutation.Update == nil {
			break
		}

		args, err := ec.field_UserMutation_update_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UserMutation.Update(childComplexity, args["id"].(uuid.UUID), args["input"].(model.UpdateUserInput)), true

	case "UserMutation.update_password":
		if e.complexity.UserMutation.UpdatePassword == nil {
			break
		}

		args, err := ec.field_UserMutation_update_password_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UserMutation.UpdatePassword(childComplexity, args["id"].(uuid.UUID), args["input"].(model.UpdatePasswordInput)), true

	case "UserQuery.get":
		if e.complexity.UserQuery.Get == nil {
			break
		}

		args, err := ec.field_UserQuery_get_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UserQuery.Get(childComplexity, args["id"].(uuid.UUID)), true

	case "UserQuery.list":
		if e.complexity.UserQuery.List == nil {
			break
		}

		args, err := ec.field_UserQuery_list_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.UserQuery.List(childComplexity, args["limit"].(*int32), args["offset"].(*int32), args["is_active"].(*bool)), true

	case "UserQuery.me":
		if e.complexity.UserQuery.Me == nil {
			break
		}

		return e.complexity.UserQuery.Me(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateOAuthInput,
		ec.unmarshalInputCreateUserInput,
		ec.unmarshalInputUpdatePasswordInput,
		ec.unmarshalInputUpdateUserInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/base.graphql", Input: `scalar Time
scalar UUID

type Query {
    user: UserQuery
    o_auth: OAuthQuery
}

type Mutation {
    user: UserMutation
    o_auth: OAuthMutation
}
`, BuiltIn: false},
	{Name: "../schema/oauth.graphql", Input: `type OAuth {
    id: UUID!
    user_id: UUID!
    ip: String!
    platform: OAuthPlatform!
    token: String!
    status: OAuthStatus!
    expire_at: Time!
    created_at: Time!
    updated_at: Time!
    login_at: Time
    user: User!
}

type OAuthQuery {
    list(limit: Int, offset: Int, user_id: UUID, platform: OAuthPlatform, status: OAuthStatus): [OAuth!]!
    get(id: UUID!): OAuth
    active_list(user_id: UUID!): [OAuth!]!
}

type OAuthMutation {
    create(input: CreateOAuthInput!): OAuth!
    update_status(id: UUID!, status: OAuthStatus!): OAuth!
    revoke(id: UUID!): Boolean!
    revoke_all(user_id: UUID!): Boolean!
}

enum OAuthPlatform {
    MOBILE
    WEB
}

enum OAuthStatus {
    ACTIVE
    INACTIVE
    BLOCKED
}

input CreateOAuthInput {
    user_id: UUID!
    ip: String!
    platform: OAuthPlatform!
    token: String!
    expire_at: Time!
}
`, BuiltIn: false},
	{Name: "../schema/user.graphql", Input: `type User {
    id: UUID!
    email: String
    phone_number: String
    password: String!
    is_active: Boolean!
    created_at: Time!
    updated_at: Time!
    o_auths: [OAuth!]
}

type UserQuery {
    list(limit: Int, offset: Int, is_active: Boolean): [User!]!
    get(id: UUID!): User
    me: User!
}

type UserMutation {
    create(input: CreateUserInput!): User!
    update(id: UUID!, input: UpdateUserInput!): User!
    update_password(id: UUID!, input: UpdatePasswordInput!): User!
    delete(id: UUID!): Boolean!
    toggle_active(id: UUID!): User!
}

input CreateUserInput {
    email: String
    phone_number: String
    password: String!
    confirm_password: String!
}

input UpdateUserInput {
    email: String
    phone_number: String
    is_active: Boolean
}

input UpdatePasswordInput {
    current_password: String!
    new_password: String!
    confirm_password: String!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
